When designing this board and debugging the PIC assembly, the following notes
give a breadcrumb trail to remind of the processes used:

	First thing was to build the software small bits at a time, starting
	with Init() and the main loop, to verify the processor is running at
	64MHz and the I/O programming done by Init was working.

	Since I was learning PIC assembly while writing this code, it was at
	times a slow process, where I had to often test individual assembly
	language commands to exercise how they operate in the debugger.

	To do this I created two separate projects in the IDE:

		tests	  - tests in C language
		tests-asm - tests in Assembler language

        I'd use the C code to sometimes generate assembly language listings
	just to see how it operates on with things like the union bit latches
	(LATAbits.RA0, etc).

	I'd use the tests-asm project to test out code snippets to make
	sure things like loops worked the way I expected, and carefully
	step through the debugger.

	The order of development went something like this:

		o Develop and test Init()    -- A necessity to just get the chip to operate.
						Started with the Init() code the C compiler generated
						for the already existing a800-opcs project, and then
						later rewrote it, since the compiler generated assembly
						used hex instead of monikers like TRISA and such.

		o Develop and test CpuSync() -- small function, easy to translate.
						Tested mostly by using the debugger's "goto to cursor"
						function, just below a line that loads state from the hardware,
						then force the WREG to be a certain value to emulate hi/lo bits
						to simulate handshaking, and used the variable watch function
						to make sure values were being set correctly (bank register vs
						access register issues)


		o Develop and test Step() -- another small function, slightly bigger than CpuSync().
					     This code had to be symmetrical for step vs. no step,
					     so was the first where I had to count instruction cycles
					     to keep the execution times symmetrical.

		o Develop and test RunMotor() -- works with Step() and a good way to test the core stepper
						 drive functionality, as with this and all the above, pulses
						 could be generated by pre-loading the vel/dir array with values
						 and letting it run to generate pulses. This code needs symmetrical
						 execution time for all the conditions.


		o Develop and test ReadVels() -- This is the largest and most complex function, a large state
						 machine with critical timing needs, and benefits from the use
						 of a jump table, which had to be carefully tested.
						 Then had to carefully run through all the states using the
						 debugger to 'step into' the 'call ReadVels' in the main program,
						 watching and manually tweaking these variables:

						 		rv_state
								is_stb
								is_vels_stb

						 ..to exercise all the various states, and single stepping the code
						 to make sure each state does what it's supposed to.

		o Finally, test the code on the IBM PC through DOS using at first the debugger
		  to initialize the 8255:

		  		o 303 82

		  ..and then toggle the strobe/svel bits by hand, and update the data bus,
		  making sure the board was responding with ACK properly, and receiving the
		  vels programmed.

		  Then used the simple a800.asm program on the PC to simply send vels to
		  CPU1. Assuming that worked, moved up to installing the A800DRV.ASM driver,
		  and then exercising that with KRUNA800.C and KRUN.C test programs,
		  (both of which should work, since the A800DRV driver should look just
		  like the RTMC driver to the C code).

		  And once that all works, OPCS should work too. I created a special work
		  directory for the A800 version of OPCS, since the ramp/speed and ldefs
		  files all had to be customized a little, since the A800 uses an IRQ speed
		  of 60Hz instead of the RTMC's 120HZ, and uses 8bit velocities instead of
		  12bit.

		  I maintain copies of all the code on the linux file server at the moment in:

		  	/net/erco/electronics/opcs-a800-stepper-board/

		  ..where in:

		  		pic/a800-opcs     -- directory containing the C PIC firmware
		  		pic/a800-opcs-asm -- directory containing the Assembly PIC firmware
				
THE DEBUGGER FOR ASSEMBLY LANGUAGE
----------------------------------

