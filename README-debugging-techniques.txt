When designing this board and debugging the PIC assembly, the following notes
give a breadcrumb trail to remind of the processes used:

	First thing was to build the software small bits at a time, starting
	with Init() and the main loop, to verify the processor is running at
	64MHz and the I/O programming done by Init was working.

	Since I was learning PIC assembly while writing this code, it was at
	times a slow process, where I had to often test individual assembly
	language commands to exercise how they operate in the debugger.

	To do this I created two separate projects in the IDE:

		tests	  - tests in C language
		tests-asm - tests in Assembler language

        I'd use the C code to sometimes generate assembly language listings
	just to see how it operates on with things like the union bit latches
	(LATAbits.RA0, etc).

	I'd use the tests-asm project to test out code snippets to make
	sure things like loops worked the way I expected, and carefully
	step through the debugger.

	The order of development went something like this:

		o Develop and test Init()    -- A necessity to just get the chip to operate.
						Started with the Init() code the C compiler generated
						for the already existing a800-opcs project, and then
						later rewrote it, since the compiler generated assembly
						used hex instead of monikers like TRISA and such.

		o Develop and test CpuSync() -- small function, easy to translate.
						Tested mostly by using the debugger's "goto to cursor"
						function, just below a line that loads state from the hardware,
						then force the WREG to be a certain value to emulate hi/lo bits
						to simulate handshaking, and used the variable watch function
						to make sure values were being set correctly (bank register vs
						access register issues)


		o Develop and test Step() -- another small function, slightly bigger than CpuSync().
					     This code had to be symmetrical for step vs. no step,
					     so was the first where I had to count instruction cycles
					     to keep the execution times symmetrical.

		o Develop and test RunMotor() -- works with Step() and a good way to test the core stepper
						 drive functionality, as with this and all the above, pulses
						 could be generated by pre-loading the vel/dir array with values
						 and letting it run to generate pulses. This code needs symmetrical
						 execution time for all the conditions.


		o Develop and test ReadVels() -- This is the largest and most complex function, a large state
						 machine with critical timing needs, and benefits from the use
						 of a jump table, which had to be carefully tested.
						 Then had to carefully run through all the states using the
						 debugger to 'step into' the 'call ReadVels' in the main program,
						 watching and manually tweaking these variables:

						 		rv_state
								is_stb
								is_vels_stb

						 ..to exercise all the various states, and single stepping the code
						 to make sure each state does what it's supposed to.

		o Finally, test the code on the IBM PC through DOS using at first the debugger
		  to initialize the 8255:

		  		o 303 82

		  ..and then toggle the strobe/svel bits by hand, and update the data bus,
		  making sure the board was responding with ACK properly, and receiving the
		  vels programmed.

		  Then used the simple a800.asm program on the PC to simply send vels to
		  CPU1. Assuming that worked, moved up to installing the A800DRV.ASM driver,
		  and then exercising that with KRUNA800.C and KRUN.C test programs,
		  (both of which should work, since the A800DRV driver should look just
		  like the RTMC driver to the C code).

		  And once that all works, OPCS should work too. I created a special work
		  directory for the A800 version of OPCS, since the ramp/speed and ldefs
		  files all had to be customized a little, since the A800 uses an IRQ speed
		  of 60Hz instead of the RTMC's 120HZ, and uses 8bit velocities instead of
		  12bit.

		  I maintain copies of all the code on the linux file server at the moment in:

		  	/net/erco/electronics/opcs-a800-stepper-board/

		  ..where in:

		  		pic/a800-opcs     -- directory containing the C PIC firmware
		  		pic/a800-opcs-asm -- directory containing the Assembly PIC firmware
				
THE DEBUGGER FOR ASSEMBLY LANGUAGE
----------------------------------
    OK, the MPLABX debugger is pretty amazing.

    You can watch all the registers and variables, and either "single step" through
    the code, or go to a position, and then run to the cursor to run a whole section
    of code.

    There's also the "Stopwatch" feature, which lets you count the #clock cycles executed
    between start and end, which was incredibly useful for making sure the various IF
    conditions in the code all executed in the same number of clock cycles, which was
    super important for this project.

    Usage:

        o First open the "a800-opcs-asm" project, bring up the source file
	  of the same name, which is the 'main' code.

	o To run in the simulator, you have to change from using the programmer
	  (PicKit4) to the simulator:

	      > Right click on the project in the "Projects" side window
	        and choose "Properties" to open the dialog

	      > Under "Categories", click "Conf:[default]" to show the
	        "Configuration" screen. 

		In the "Hardware Tool:" browser, "PICkit 4" is probably selected.
		
		Change this, selecting "Simulator" instead.

		Hit Apply/OK

	o Optionally set a breakpoint in the code that's in main() somewhere
	  after the hardware init is done (e.g. the call to Init())

	o Now click "Debug -> Debug main project"
	  This will "compile" and run the simulator in the debugger mode.

	o When the program is running in the debugger, the red "STOP" and orange "PAUSE"
	  buttons will activate.

	  If a breakpoint is set, the debugger will pause automatically.

	  If no breakpoint was set, the code will run forever; push PAUSE 
	  to stop the simulation. It will stop you somewhere in the code.

	o Assuming you set a breakpoint, and want to time the number of cycles
	  between two points in the code:

	     > First make sure "Stopwatch" is enabled; choose:

	         Window -> Debugging -> Stopwatch

	       Stopwatch will either show you accumulated time, or
	       the time between executions. You probably want the latter,
	       so make sure in the "Stopwatch" window the "Reset stopwatch on Run"
	       is set.
	  
	     > Click on the instruction you want to start running from
	       and hit "Set PC At Cursor". That will be the starting point.

	     > Click on the instruction you want to stop at, and click
	       "Run to cursor"

	     > The simulator will run between the two points, and when
	       it stops, Stopwatch will show the execution time in 
	       instruction cycles.

WATCHING VARIABLES
------------------
    To watch variables, choose:

	Window -> Debugging -> Variables

    ..to show the window with the list of variables you're watching, if any.
    To add new variables to watch, either click the "+Diamond" icon, or right
    click on the window and choose "New Watch".

    It'll prompt for the variable name, or let you choose from a big list
    of global symbols.

    To delete watches, you can highlight a bunch and use Right Click -> "Delete".

    You can watch registers, since they're just like variables, they have
    a memory location.

    For variables, you have to tell the watcher how large the variable is,
    otherwise it assumes 1 byte. Under the "Type" column you can change the
    size by selecting the variable, right click and choose:

	    "User Defined Size" -> 16 bits, 32 bits, etc.

    You can also change how it shows the value, in either hex or decimal
    or binary or as an ascii character. For that, right click and choose:

	    "Display Value Column As" -> Character/Hex/Decimal/etc.

LEAVING DEBUG MODE
------------------

    Hit the STOP button or choose Debug -> Finish Debugger Session.

RETURNING TO PROGRAMMING CHIPS
------------------------------

    When done with the simulator, be sure to switch back to using the
    PicKit4:

    	> Right-click on the project, choose Properties to open the dialog
	> Under the "Categories" choose "Conf:[default]"
	> Under Configuration, choose "PICkit4"
	> hit Apply/OK.



