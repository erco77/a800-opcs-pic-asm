vim: autoindent tabstop=8 shiftwidth=4 expandtab softtabstop=4

README-debugging-techniques.txt
-----------------------------------------------------------------------------

When designing this board and debugging the PIC assembly, the following notes
give a breadcrumb trail to remind of the processes used:

        First thing was to build the software small bits at a time, starting
        with Init() and the main loop, to verify the processor is running at
        64MHz and the I/O programming done by Init was working.

        Since I was learning PIC assembly while writing this code, it was at
        times a slow process, where I had to often test individual assembly
        language commands to exercise how they operate in the debugger.

        To do this I created two separate projects in the IDE:

                tests     - tests in C language
                tests-asm - tests in Assembler language

        I'd use the C code to sometimes generate assembly language listings
        just to see how it operates on with things like the union bit latches
        (LATAbits.RA0, etc).

        I'd use the tests-asm project to test out code snippets to make
        sure things like loops worked the way I expected, and carefully
        step through the debugger.

        The order of development went something like this:

                o Develop and test Init()    -- A necessity to just get the chip to operate.
                                                Started with the Init() code the C compiler generated
                                                for the already existing a800-opcs project, and then
                                                later rewrote it, since the compiler generated assembly
                                                used hex instead of monikers like TRISA and such.

                o Develop and test CpuSync() -- small function, easy to translate.
                                                Tested mostly by using the debugger's "goto to cursor"
                                                function, just below a line that loads state from the hardware,
                                                then force the WREG to be a certain value to emulate hi/lo bits
                                                to simulate handshaking, and used the variable watch function
                                                to make sure values were being set correctly (bank register vs
                                                access register issues)


                o Develop and test Step() -- another small function, slightly bigger than CpuSync().
                                             This code had to be symmetrical for step vs. no step,
                                             so was the first where I had to count instruction cycles
                                             to keep the execution times symmetrical.

                o Develop and test RunMotor() -- works with Step() and a good way to test the core stepper
                                                 drive functionality, as with this and all the above, pulses
                                                 could be generated by pre-loading the vel/dir array with values
                                                 and letting it run to generate pulses. This code needs symmetrical
                                                 execution time for all the conditions.


                o Develop and test ReadVels() -- This is the largest and most complex function, a large state
                                                 machine with critical timing needs, and benefits from the use
                                                 of a jump table, which had to be carefully tested.
                                                 Then had to carefully run through all the states using the
                                                 debugger to 'step into' the 'call ReadVels' in the main program,
                                                 watching and manually tweaking these variables:

                                                                rv_state
                                                                is_stb
                                                                is_vels_stb

                                                 ..to exercise all the various states, and single stepping the code
                                                 to make sure each state does what it's supposed to.

                o Finally, test the code on the IBM PC through DOS using at first the debugger
                  to initialize the 8255:

                                C:\> debug
                                o 303 82

                  ..and then toggle the strobe/svel bits by hand, and update the data bus,
                  making sure the board was responding with ACK properly, and receiving the
                  vels programmed.

                  Then used the simple a800.asm program on the PC to simply send vels to
                  CPU1. Assuming that worked, moved up to installing the A800DRV.ASM driver,
                  and then exercising that with KRUNA800.C and KRUN.C test programs,
                  (both of which should work, since the A800DRV driver should look just
                  like the RTMC driver to the C code).

                  And once that all works, OPCS should work too. I created a special work
                  directory for the A800 version of OPCS, since the ramp/speed and ldefs
                  files all had to be customized a little, since the A800 uses an IRQ speed
                  of 60Hz instead of the RTMC's 120HZ, and uses 8bit velocities instead of
                  12bit.

                  I maintain copies of all the code on the linux file server at the moment in:

                        /net/erco/electronics/opcs-a800-stepper-board/

                  ..where in:

                                pic/a800-opcs     -- directory containing the C PIC firmware
                                pic/a800-opcs-asm -- directory containing the Assembly PIC firmware

THE DEBUGGER FOR ASSEMBLY LANGUAGE
----------------------------------
    OK, the MPLABX debugger is pretty amazing.

    You can watch all the registers and variables, and either "single step" through
    the code, or go to a position, and then run to the cursor to run a whole section
    of code.

    There's also the "Stopwatch" feature, which lets you count the #clock cycles executed
    between start and end, which was incredibly useful for making sure the various IF
    conditions in the code all executed in the same number of clock cycles, which was
    super important for this project.

    Usage:

        o First open the "a800-opcs-asm" project, bring up the source file
          of the same name, which is the 'main' code.

        o To run in the simulator, you have to change from using the programmer
          (PicKit4) to the simulator:

              > Right click on the project in the "Projects" side window
                and choose "Properties" to open the dialog

              > Under "Categories", click "Conf:[default]" to show the
                "Configuration" screen. 

                In the "Hardware Tool:" browser, "PICkit 4" is probably selected.
                
                Change this, selecting "Simulator" instead.

                Hit Apply/OK

        o Optionally set a breakpoint in the code that's in main() somewhere
          after the hardware init is done (e.g. the call to Init())

        o Now click "Debug -> Debug main project"
          This will "compile" and run the simulator in the debugger mode.

        o When the program is running in the debugger, the red "STOP" and orange "PAUSE"
          buttons will activate.

          If a breakpoint is set, the debugger will pause automatically.

          If no breakpoint was set, the code will run forever; push PAUSE 
          to stop the simulation. It will stop you somewhere in the code.

        o Assuming you set a breakpoint, and want to time the number of cycles
          between two points in the code:

             > First make sure "Stopwatch" is enabled; choose:

                 Window -> Debugging -> Stopwatch

               Stopwatch will either show you accumulated time, or
               the time between executions. You probably want the latter,
               so make sure in the "Stopwatch" window the "Reset stopwatch on Run"
               is set.
          
             > Click on the instruction you want to start running from
               and hit "Set PC At Cursor". That will be the starting point.

             > Click on the instruction you want to stop at, and click
               "Run to cursor"

             > The simulator will run between the two points, and when
               it stops, Stopwatch will show the execution time in 
               instruction cycles.

WATCHING VARIABLES
------------------
    To watch variables, choose:

        Window -> Debugging -> Variables

    ..to show the window with the list of variables you're watching, if any.
    To add new variables to watch, either click the "+Diamond" icon, or right
    click on the window and choose "New Watch".

    It'll prompt for the variable name, or let you choose from a big list
    of global symbols.

    To delete watches, you can highlight a bunch and use Right Click -> "Delete".

    You can watch registers, since they're just like variables, they have
    a memory location.

    For variables, you have to tell the watcher how large the variable is,
    otherwise it assumes 1 byte. Under the "Type" column you can change the
    size by selecting the variable, right click and choose:

            "User Defined Size" -> 16 bits, 32 bits, etc.

    You can also change how it shows the value, in either hex or decimal
    or binary or as an ascii character. For that, right click and choose:

            "Display Value Column As" -> Character/Hex/Decimal/etc.

LEAVING DEBUG MODE
------------------

    Hit the STOP button or choose Debug -> Finish Debugger Session.

RETURNING TO PROGRAMMING CHIPS
------------------------------

    When done with the simulator, be sure to switch back to using the
    PicKit4:

        > Right-click on the project, choose Properties to open the dialog
        > Under the "Categories" choose "Conf:[default]"
        > Under Configuration, choose "PICkit4"
        > hit Apply/OK.

04/13/2024 - HOW I DEBUGGED REV-A
---------------------------------
    This is what I did when I found a bug in REV-A, and needed to do work
    towards making a new REV-B.

    Revision A had a bug with the 16bit greater-than-equal test that caused
    problems with the higher stepper motor speeds.

    To debug the problem, first made a copy of the old REV-A project
    called REV-A-DEBUGGING so I could safely make changes to the REV-A
    code without screwing up the original REV-A project.

        > Started MPLABX 5.25

        > File -> Open Project, choose: a800-opcs-asm-REV-A project

        > Right clicked on the project and chose "Copy.."

        > Made a copy of the project called a800-opcs-asm-REV-A-DEBUGGING.X

    Then, in order to run the software on just a chip sitting in the programmer,
    (without it running on the A800 card), I had to:

        > Changed the config.h file so that it used the internal clock
          instead of the 16MHz crystal on the A800 card that drives both CPUs.
          There are comments in the code that make that clear, but essentially:

          """

            ;; *** INTERNAL PIC OSCILLATOR ***
            ;;     Use this when debugging chip /without/ A800 board, i.e. running on the proto board.
            ;;
              CONFIG  RSTOSC = HFINTOSC_64MHZ ; Power-up default value for COSC bits (HFINTOSC with HFFRQ = 64 MHz
             .___
             |\
             | \___ Uncommented this to use internal oscillator


            ;; *** EXTERNAL CRYSTAL OSCILLATOR ***
            ;;     Use this when actually running on the A800 board with the IBM PC
            ;;     using common crystal locked timing across both processors.
            ;;
            ; CONFIG  RSTOSC = EXTOSC_4PLL    ; Power-up default value for COSC bits (HFINTOSC with HFFRQ = 64 MHz
             .___
             |\
             | \___ Commented this out, as this only works with the A800 board

          """


        > Comment out the calls to CpuSync(), as that would get stuck in the
          debugger.

        > Since I was debugging the RunMotors() code, I commented out 
          the channel loop so I could just focus on the A channel

     DEBUGGING
     ---------
     Then, set a breakpoint at the head of the main loop so that when the
     debugger runs, it immediately stops with the processor's Init() function
     already called, so the processor's crystal clock and ports and features
     are all initialized correctly, so that the debugger will run the code
     in the hardware environment state needed.

     From there, the usual debugging techniques:

        > Hit the Debug shortcut to start the debugger, which builds the code
          and puts it into a state for the debugger to run

        > "Step Over" / "Step Into" buttons to run the code

        > Set breakpoints by left-clicking on the line numbers

        > Use "Watch" to watch variables/regs as the change, or type new values into them

        > You can click a line of code and right click to set the PC (Program Counter) 
          to be that line, so you can then single step through the code onward.

     NOTE: The hardware can only support ONE BREAKPOINT.
           So for multiple breakpoints, switch from the PicKit 4 to the
           "Simulator", so that hitting Debug runs the sim.
           Then you can use the stopwatch function (Window -> Debugging.. -> Stopwatch)
           to time execution of each instruction during single step, etc.

